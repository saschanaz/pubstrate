#!@GUILE@ \
--no-auto-compile -e dispatch-subcommand -s
!#

(use-modules (pubstrate webapp app)
             (pubstrate webapp store)
             (pubstrate webapp store-gdbm)
             (ice-9 getopt-long)
             (ice-9 match)
             ((system repl server)
              #:renamer (symbol-prefix-proc 'repl:)))


;;; "run" subcommand

;; I guess for now we just want to be able to set a prefix
;; and a store location.

(define run-option-spec
  '((help (single-char #\h) (value #f))
    (db-dir (single-char #\d) (value #t))
    (host (single-char #\h) (value #t))
    (port (single-char #\p) (value #t))
    (base-uri (value #t))
    (repl-server (single-char #\r) (value #f))))

(define* (get-store-from-db-path db-path #:key (warn-if-memory-store #t))
  (if db-path
      (make-gdbm-store db-path)
      (begin
        (if warn-if-memory-store
            (display
             "WARNING: db-path not provided, so using memory store only\n"
             (current-error-port)))
        (make-memory-store))))

(define %webapp-help-text
  "\
pubstrate-web run [options] configfile
  -h, --help           Display this help
  -d, --db-dir=PATH    Path to a directory where GDBM databases will be stored.
  -h, --host=HOST      Server host address.  Defaults to localhost.
  -p, --port=PORT      Server port.  Defaults to 8080.

      --base-uri=BASE-URI
                       Base URI to generate URLs from.  Normally generated from
                       host and port.

  -r, --repl-server[=REPL-PORT]
                       Run a REPL server (on REPL-PORT if provided, otherwise
                       on port 37146)")

(define (run-cli args)
  ;; Maybe append a keyword argument to a list of existing
  ;; keyword arguments
  (define (maybe-kwarg kwarg val)
    (lambda (current-kwargs)
      (if val
          (append (list kwarg val)
                  current-kwargs)
          current-kwargs)))
  (let ((options (getopt-long args run-option-spec)))
    (cond
     ((option-ref options 'help #f)
      (display %webapp-help-text) (newline))
     (else
      (let* ((store (get-store-from-db-path
                       (option-ref options 'db-dir #f)))
             (get-option
              (lambda (option)
                (option-ref options option #f)))
             ;; Build up all the keyword arguments sent to run-server
             ;; depending on the options passed in
             (kwargs
              ((compose
                (maybe-kwarg #:host (get-option 'host))
                (maybe-kwarg #:port (get-option 'port))
                (maybe-kwarg #:base-uri (get-option 'base-uri)))
               (list #:store store))))
        ;; Enable the REPL server if requested
        (match (option-ref options 'repl-server #f)
          ;; If false, do nothing
          (#f #f)
          ;; If it's a string and a number, serve the repl on this
          ;; port number on localhost
          ((and (? string? _) (= string->number repl-port-number))
           (repl:spawn-server (repl:make-tcp-server-socket #:port repl-port-number)))
          ;; Anything else, start with the default port
          (_ (repl:spawn-server)))
        ;; Now run the server! :)
        (apply run-webapp
               ;; Announce that we're running on start-up
               #:announce (current-output-port)  ; @@: maybe STDERR instead?
               kwargs))))))


;;; Main / subcommand dispatch CLI
;;; ==============================

;; TODO
(define (init-cli args)
  'TODO)

(define subcommands
  `(("run" . ,run-cli)
    ;; ("demo" . ,demo-cli)
    ("init" . ,init-cli)))

(define main-option-spec
  '((help (single-char #\h) (value #f))
    (version (value #f))))

(define (dispatch-subcommand args)
  (define options (getopt-long args main-option-spec
                               #:stop-at-first-non-option #t))
  (define main-args
    (assoc-ref options '()))

  (cond
   ;; Main help goes here!
   ((assoc-ref options 'help)
    (display "Main help goes here!\n"))
   ;; Show verison number
   ((assoc-ref options 'version)
    (display "This would be a great place to display our version!\n"))
   ;; Also show help, since no command given
   ((eq? main-args '())
    (display "Also show help, since no command given\n"))
   ;; Dispatch to subcommand
   ((assoc-ref subcommands (car main-args)) =>
    (lambda (subcmd)
      (subcmd main-args)))
   ;; Invalid subcommand, list available subcommands
   (else
    (display "Inform this was invalid subcommand, list subcommand options\n"))))
